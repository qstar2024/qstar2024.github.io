<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Dice Rolling Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: url('bgp_dice.png') no-repeat center center fixed;
            background-size: cover;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
        }

        #backToHome {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            text-decoration: none;
            z-index: 101;
            transition: background-color 0.3s ease;
        }

        #backToHome:hover {
            background-color: rgba(255, 255, 255, 0.4);
        }
        
        #rollButton {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            transition: all 0.3s ease;
        }
        
        #rollButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }
        
        #rollButton:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
        }
        
        #results {
            margin-top: 20px;
            font-size: 16px;
        }
        
        #total {
            font-size: 24px;
            font-weight: bold;
            color: #f39c12;
            margin-top: 10px;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/",
                "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"
            }
        }
    </script>

</head>
<body>
    <div id="gameContainer">
        <a href="index.html" id="backToHome">Back to Home</a>
        <div id="ui">
            <button id="rollButton">Roll Dice</button>
            <div id="results"></div>
            <div id="total"></div>
        </div>
    </div>

    <script defer type="module">
        // Ensure THREE and CANNON are loaded before starting the game
        import * as THREE from "three";
        import * as CANNON from "cannon-es";

        class DiceGame {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.world = new CANNON.World();
                this.dice = [];
                this.diceResults = [];
                this.isRolling = false;
                this.init();
            }
            
            init() {
                // Renderer setup
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x000000, 0); // Set clear color to transparent
                this.renderer.setPixelRatio(window.devicePixelRatio); // Handle high-DPI displays
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
                
                // Physics world setup
                this.world.gravity.set(0, -20, 0);
                this.world.broadphase = new CANNON.NaiveBroadphase();
                this.world.defaultContactMaterial.friction = 0.4;
                this.world.defaultContactMaterial.restitution = 0.3;
                
                // Camera position
                this.camera.position.set(0, 15, 20);
                this.camera.lookAt(0, 0, 0);
                
                // Lighting
                this.setupLighting();
                
                // Create bowl
                this.createBowl();
                
                // Create dice
                this.createDice();
                
                // Event listeners
                this.setupEventListeners();
                
                // Start animation loop
                this.animate();
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);
                
                // Directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // Point light for warmth
                const pointLight = new THREE.PointLight(0xffa500, 0.5, 50);
                pointLight.position.set(0, 10, 0);
                this.scene.add(pointLight);
            }
            
            createBowl() {
                // Create a larger, thicker concave bowl
                const bowlRadius = 10;
                const bowlThickness = 0.5;
                
                // Outer bowl geometry
                const outerBowlGeometry = new THREE.SphereGeometry(bowlRadius, 64, 32, 0, Math.PI * 2, 0, Math.PI * 0.55);
                // Inner bowl geometry (slightly smaller for thickness)
                const innerBowlGeometry = new THREE.SphereGeometry(bowlRadius - bowlThickness, 64, 32, 0, Math.PI * 2, 0, Math.PI * 0.55);
                
                // Create bowl material
                const bowlMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xcc3333,
                    shininess: 100,
                    side: THREE.FrontSide
                });
                
                // Create outer bowl
                const outerBowl = new THREE.Mesh(outerBowlGeometry, bowlMaterial);
                outerBowl.receiveShadow = true;
                outerBowl.castShadow = true;
                outerBowl.position.set(0, -20, 0);
                outerBowl.rotation.x = Math.PI; // Make it concave upwards
                this.scene.add(outerBowl);
                
                // Create inner bowl (inverted to create hollow effect)
                const innerBowlMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xcc3333,
                    shininess: 100,
                    side: THREE.BackSide
                });
                const innerBowl = new THREE.Mesh(innerBowlGeometry, innerBowlMaterial);
                innerBowl.receiveShadow = true;
                innerBowl.position.set(0, -20, 0);
                innerBowl.rotation.x = Math.PI;
                this.scene.add(innerBowl);
                
                // Physics: Create concave bowl using multiple angled planes
                const numSegments = 24;
                const bowlPhysicsRadius = bowlRadius - bowlThickness / 2;
                const bowlDepth = 6;
                
                for (let i = 0; i < numSegments; i++) {
                    const angle = (i / numSegments) * Math.PI * 2;
                    const nextAngle = ((i + 1) / numSegments) * Math.PI * 2;
                    
                    // Create angled wall segments
                    const wallShape = new CANNON.Plane();
                    const wallBody = new CANNON.Body({ mass: 0 });
                    wallBody.addShape(wallShape);
                    
                    // Position and orient the wall segment
                    const x = Math.cos(angle) * bowlPhysicsRadius;
                    const z = Math.sin(angle) * bowlPhysicsRadius;
                    wallBody.position.set(x * 0.7, -6 + bowlDepth * 0.3, z * 0.7);
                    
                    // Rotate wall to face inward and angle downward
                    const wallQuaternion = new CANNON.Quaternion();
                    wallQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), angle + Math.PI);
                    const tiltQuaternion = new CANNON.Quaternion();
                    tiltQuaternion.setFromAxisAngle(new CANNON.Vec3(Math.sin(angle), 0, -Math.cos(angle)), Math.PI * 0.25);
                    wallBody.quaternion = wallQuaternion.mult(tiltQuaternion);
                    
                    wallBody.material = new CANNON.Material({ friction: 0.4, restitution: 0.2 });
                    this.world.addBody(wallBody);
                }
                
                // Bowl bottom - curved surface using multiple small planes
                const bottomSegments = 16;
                for (let i = 0; i < bottomSegments; i++) {
                    for (let j = 0; j < bottomSegments; j++) {
                        const x = (i - bottomSegments/2) * 1.2;
                        const z = (j - bottomSegments/2) * 1.2;
                        const distance = Math.sqrt(x*x + z*z);
                        
                        if (distance < bowlPhysicsRadius * 0.8) {
                            const bottomShape = new CANNON.Plane();
                            const bottomBody = new CANNON.Body({ mass: 0 });
                            bottomBody.addShape(bottomShape);
                            
                            // Create curved bottom by angling planes
                            const curvature = distance / (bowlPhysicsRadius * 0.8);
                            const yOffset = -6 - bowlDepth + curvature * curvature * 2;
                            bottomBody.position.set(x, yOffset, z);
                            
                            // Angle the plane based on position
                            if (distance > 0.5) {
                                const tiltAngle = curvature * 0.3;
                                const tiltQuaternion = new CANNON.Quaternion();
                                tiltQuaternion.setFromAxisAngle(new CANNON.Vec3(-z/distance, 0, x/distance), tiltAngle);
                                const baseQuaternion = new CANNON.Quaternion();
                                baseQuaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                                bottomBody.quaternion = baseQuaternion.mult(tiltQuaternion);
                            } else {
                                bottomBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                            }
                            
                            bottomBody.material = new CANNON.Material({ friction: 0.5, restitution: 0.1 });
                            this.world.addBody(bottomBody);
                        }
                    }
                }
            }
            
            createDice() {
                for (let i = 0; i < 6; i++) {
                    const dice = this.createSingleDie(i);
                    this.dice.push(dice);
                }
            }
            
            createSingleDie(index) {
                // Create dice geometry
                const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                
                // Create materials for each face
                const materials = [];
                const faceNumbers = [1, 2, 3, 4, 5, 6];
                
                faceNumbers.forEach(number => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 128;
                    canvas.height = 128;
                    const context = canvas.getContext('2d');
                    
                    // White background
                    context.fillStyle = '#ffffff';
                    context.fillRect(0, 0, 128, 128);
                    
                    // Border
                    context.strokeStyle = '#cccccc';
                    context.lineWidth = 2;
                    context.strokeRect(2, 2, 124, 124);
                    
                    // Number color (red for 1 and 4, black for others)
                    context.fillStyle = (number === 1 || number === 4) ? '#cc0000' : '#000000';
                    context.font = 'bold 60px Arial';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    
                    // Draw dots instead of numbers for authenticity
                    this.drawDots(context, number, (number === 1 || number === 4) ? '#cc0000' : '#000000');
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    materials.push(new THREE.MeshPhongMaterial({ map: texture }));
                });
                
                const diceMesh = new THREE.Mesh(geometry, materials);
                diceMesh.castShadow = true;
                diceMesh.receiveShadow = true;
                
                // Position dice statically in the bowl at initialization
                const angle = (index / 6) * Math.PI * 2;
                const radius = 3 + Math.random() * 2; // Random radius within bowl
                diceMesh.position.set(
                    0, //Math.cos(angle) * radius,
                    -20, // Place dice at bottom of bowl
                    0 //Math.sin(angle) * radius
                );
                
                this.scene.add(diceMesh);
                
                // Physics body
                const shape = new CANNON.Box(new CANNON.Vec3(0.75, 0.75, 0.75));
                const body = new CANNON.Body({ mass: 1 });
                body.addShape(shape);
                body.position.copy(diceMesh.position);
                body.material = new CANNON.Material({ friction: 0.4, restitution: 0.3 });
                
                // Start with dice at rest (no initial velocity)
                body.velocity.set(0, 0, 0);
                body.angularVelocity.set(0, 0, 0);
                body.linearDamping = 0.2;
                body.angularDamping = 0.2;
                
                this.world.addBody(body);
                
                return { mesh: diceMesh, body: body };
            }
            
            drawDots(context, number, color) {
                context.fillStyle = color;
                const dotSize = 12;
                const positions = {
                    1: [[64, 64]],
                    2: [[32, 32], [96, 96]],
                    3: [[32, 32], [64, 64], [96, 96]],
                    4: [[32, 32], [96, 32], [32, 96], [96, 96]],
                    5: [[32, 32], [96, 32], [64, 64], [32, 96], [96, 96]],
                    6: [[32, 32], [96, 32], [32, 64], [96, 64], [32, 96], [96, 96]]
                };
                
                positions[number].forEach(([x, y]) => {
                    context.beginPath();
                    context.arc(x, y, dotSize, 0, Math.PI * 2);
                    context.fill();
                });
            }
            
            rollDice() {
                //if (this.isRolling) return;
                
                this.isRolling = true;
                document.getElementById('rollButton').disabled = true;
                document.getElementById('results').innerHTML = '';
                document.getElementById('total').innerHTML = '';
                
                // Phase 1: Lift dice slightly above the bowl
                this.dice.forEach((dice, index) => {
                    const currentPos = dice.body.position;
                    const angle = (index / 6) * Math.PI * 2;
                    const radius = 3 + Math.random() * 2;
                    
                    // Lift dice just above the bowl rim (small height)
                    dice.body.position.set(
                        0, //Math.cos(angle) * radius,
                        -15, // Just above bowl rim
                        0 //Math.sin(angle) * radius
                    );
                    
                    // Reset velocities for controlled lift
                    dice.body.velocity.set(0, 0, 0);
                    dice.body.angularVelocity.set(0, 0, 0);
                    
                    // Random orientation for each dice
                    dice.body.quaternion.set(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).normalize();
                });
                
                // Phase 2: After a brief pause, release dice with physics
                setTimeout(() => {
                    this.dice.forEach((dice, index) => {
                        // Add small random impulse to start the rolling
                        const randomImpulse = new CANNON.Vec3(
                            (Math.random() - 0.5) * 2,
                            Math.random() * 1,
                            (Math.random() - 0.5) * 2
                        );
                        
                        dice.body.velocity.copy(randomImpulse);
                        
                        // Add random spinning with varying intensity (1-3 seconds worth)
                        const spinIntensity = 2 + Math.random() * 3;
                        dice.body.angularVelocity.set(
                            (Math.random() - 0.5) * spinIntensity,
                            (Math.random() - 0.5) * spinIntensity,
                            (Math.random() - 0.5) * spinIntensity
                        );
                        
                        // Set damping for gradual settling
                        dice.body.linearDamping = 0.5;
                        dice.body.angularDamping = 0.5;
                    });
                }, 300); // 300ms pause before releasing
                
                // Check for results after dice settle
                setTimeout(() => {
                    this.checkResults();
                }, 4500); // Total time: 300ms lift + 4200ms settling
            }
            
            checkResults() {
                this.diceResults = [];
                
                this.dice.forEach((dice, index) => {
                    // Use the physics body for accurate face detection
                    const result = this.getDiceValue(dice.body);
                    this.diceResults.push(result);
                });
                
                this.displayResults();
                this.isRolling = false;
                document.getElementById('rollButton').disabled = false;
            }
            
            getDiceValue(diceBody) {
                // Get the dice's current rotation quaternion
                const quaternion = diceBody.quaternion;
                
                // Define the face normal vectors for a standard die
                // Face 1: +Y (top), Face 6: -Y (bottom)
                // Face 2: +Z (front), Face 5: -Z (back) 
                // Face 3: +X (right), Face 4: -X (left)
                const faceNormals = [
                    new CANNON.Vec3(0, 1, 0),   // Face 1 (top)
                    new CANNON.Vec3(0, 0, 1),   // Face 2 (front)
                    new CANNON.Vec3(1, 0, 0),   // Face 3 (right)
                    new CANNON.Vec3(-1, 0, 0),  // Face 4 (left)
                    new CANNON.Vec3(0, 0, -1),  // Face 5 (back)
                    new CANNON.Vec3(0, -1, 0)   // Face 6 (bottom)
                ];
                
                // World up vector
                const worldUp = new CANNON.Vec3(0, 1, 0);
                
                let maxDot = -1;
                let topFace = 1;
                
                // Check which face normal is most aligned with world up
                faceNormals.forEach((normal, index) => {
                    // Rotate the face normal by the dice's current rotation
                    const rotatedNormal = quaternion.vmult(normal);
                    
                    // Calculate dot product with world up vector
                    const dot = rotatedNormal.dot(worldUp);
                    
                    // The face with the highest dot product is facing up
                    if (dot > maxDot) {
                        maxDot = dot;
                        topFace = index + 1;
                    }
                });
                
                return topFace;
            }
            
            displayResults() {
                const pattern = this.getDicePattern(this.diceResults);
                document.getElementById('results').innerHTML = `骰子: ${this.diceResults.join(', ')}`;
                document.getElementById('total').innerHTML = `结果: ${pattern}`;
            }

            getDicePattern(diceResults) {
                const counts = {};
                diceResults.forEach(num => {
                    counts[num] = (counts[num] || 0) + 1;
                });

                const num4s = counts[4] || 0;
                const uniqueNumbers = Object.keys(counts).length;
                const sortedResults = [...diceResults].sort((a, b) => a - b);

                // Helper to check for N same numbers
                const hasNofSame = (n) => {
                    for (const num in counts) {
                        if (counts[num] === n) return true;
                    }
                    return false;
                };

                // Helper to get a number that appears N times
                const getNumWithNCount = (n) => {
                    for (const num in counts) {
                        if (counts[num] === n) return parseInt(num);
                    }
                    return null;
                };

                // Helper to check for specific counts of numbers
                const checkCounts = (targetCounts) => {
                    const currentCounts = {};
                    diceResults.forEach(num => {
                        currentCounts[num] = (currentCounts[num] || 0) + 1;
                    });
                    for (const num in targetCounts) {
                        if (currentCounts[num] !== targetCounts[num]) return false;
                    }
                    for (const num in currentCounts) {
                        if (!targetCounts[num] && currentCounts[num] > 0) return false; // Ensure no extra numbers
                    }
                    return true;
                };

                // 状元插金花
                if (num4s === 4 && counts[1] === 2) return "狀元插金花";

                // 六殕紅
                if (num4s === 6) return "六殕紅";

                // 六殕烏
                if (hasNofSame(6)) return "六殕烏";

                // 五红带X
                if (num4s === 5) {
                    if (counts[6] === 1) return "五紅帶六";
                    if (counts[5] === 1) return "五紅帶五";
                    if (counts[3] === 1) return "五紅帶三";
                    if (counts[2] === 1) return "五紅帶二";
                    if (counts[1] === 1) return "五紅帶一";
                }

                // 状元带X
                if (num4s === 4) {
                    const remaining = diceResults.filter(d => d !== 4).sort((a, b) => a - b);
                    if (remaining.length === 2) {
                        if (remaining[0] === 6 && remaining[1] === 6) return "狀元帶十二";
                        if (remaining[0] === 5 && remaining[1] === 6) return "狀元帶十一";
                        if (remaining[0] === 5 && remaining[1] === 5) return "狀元帶十";
                        if (remaining[0] === 3 && remaining[1] === 6) return "狀元帶九";
                        if (remaining[0] === 2 && remaining[1] === 6) return "狀元帶八";
                        if (remaining[0] === 3 && remaining[1] === 5) return "狀元帶八";
                        if (remaining[0] === 1 && remaining[1] === 6) return "狀元帶七";
                        if (remaining[0] === 2 && remaining[1] === 5) return "狀元帶七";
                        if (remaining[0] === 1 && remaining[1] === 5) return "狀元帶六";
                        if (remaining[0] === 3 && remaining[1] === 3) return "狀元帶六";
                        if (remaining[0] === 2 && remaining[1] === 3) return "狀元帶五";
                        if (remaining[0] === 1 && remaining[1] === 3) return "狀元帶四";
                        if (remaining[0] === 2 && remaining[1] === 2) return "狀元帶四";
                        if (remaining[0] === 1 && remaining[1] === 2) return "狀元帶三";
                    }
                }

                // 对堂
                if (uniqueNumbers === 6) return "對堂";

                // 三红
                if (num4s === 3) return "三紅";

                // 四进
                if (hasNofSame(4)) {
                    const numWith4Count = getNumWithNCount(4);
                    if (numWith4Count !== 4) { // Not a 4-of-a-kind of 4s
                        if (num4s === 2) return "四進帶二舉";
                        if (num4s === 1) return "四進帶一秀";
                        return "四進";
                    }
                }

                // 二举
                if (num4s === 2) return "二舉";

                // 一秀
                if (num4s === 1) return "一秀";

                return "無";
            }
            
            setupEventListeners() {
                document.getElementById('rollButton').addEventListener('click', () => {
                    this.rollDice();
                });
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Step physics
                this.world.step(1/60);
                
                // Update dice meshes to match physics bodies
                this.dice.forEach(dice => {
                    dice.mesh.position.copy(dice.body.position);
                    dice.mesh.quaternion.copy(dice.body.quaternion);
                });
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize game
        new DiceGame();
    </script>
</body>
</html>